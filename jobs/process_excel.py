# jobs/process_excel.py - OPTIMIZE EDÄ°LMÄ°Åž VERSÄ°YON
"""
Excel Ä°ÅŸleme GÃ¶revi - Optimize EdilmiÅŸ
Tek bir ana fonksiyon ile tÃ¼m modlarÄ± destekler
"""

import asyncio
import zipfile
import tempfile
from pathlib import Path
from typing import Dict, Any, List
from openpyxl import load_workbook

from utils.excel_cleaner import clean_excel_headers
from utils.excel_splitter import split_excel_by_groups
from utils.mailer import send_email_with_attachment
from utils.group_manager import group_manager
from utils.logger import logger
from config import config


class ProcessMode:
    """Ä°ÅŸlem modlarÄ± iÃ§in sabitler"""
    NORMAL = "normal"  # Gruplara ayÄ±rÄ±p her grubun mail listesine gÃ¶nder
    PERSONAL = "personal"  # Tek dosya olarak kiÅŸisel maile gÃ¶nder
    ZIP = "zip"  # Gruplara ayÄ±rÄ±p ZIP yaparak kiÅŸisel maile gÃ¶nder


async def process_excel_task(input_path: Path, user_id: int, mode: str = ProcessMode.ZIP) -> Dict[str, Any]:
    """
    Excel iÅŸleme gÃ¶revini yÃ¼rÃ¼tÃ¼r - TÃ¼m modlarÄ± destekler
    
    Args:
        input_path: Girdi Excel dosyasÄ± yolu
        user_id: KullanÄ±cÄ± ID'si
        mode: Ä°ÅŸlem modu (normal, personal, zip)
    
    Returns:
        Ä°ÅŸlem sonucu sÃ¶zlÃ¼ÄŸÃ¼
    """
    cleaning_result = None
    temp_output_path = None
    
    try:
        logger.info(f"Excel iÅŸleme baÅŸlatÄ±ldÄ±: {input_path.name}, KullanÄ±cÄ±: {user_id}, Mod: {mode}")

        # 1. Excel dosyasÄ±nÄ± temizle ve dÃ¼zenle
        cleaning_result = clean_excel_headers(str(input_path))
        if not cleaning_result["success"]:
            error_msg = f"Excel temizleme hatasÄ±: {cleaning_result.get('error', 'Bilinmeyen hata')}"
            logger.error(error_msg)
            return {"success": False, "error": error_msg}
        
        logger.info(f"Excel temizlendi: {cleaning_result['row_count']} satÄ±r")

        # MODA GÃ–RE Ä°ÅžLEM YAP
        if mode == ProcessMode.PERSONAL:
            result = await _process_personal_mode(cleaning_result, input_path.name)
        elif mode == ProcessMode.NORMAL:
            result = await _process_normal_mode(cleaning_result)
        else:  # ZIP mod (varsayÄ±lan)
            result = await _process_zip_mode(cleaning_result, input_path.name)
        
        result["user_id"] = user_id
        result["mode"] = mode
        return result
        
    except Exception as e:
        logger.error(f"Ä°ÅŸlem gÃ¶revi hatasÄ±: {e}", exc_info=True)
        return {"success": False, "error": str(e)}
    finally:
        # GeÃ§ici dosyalarÄ± temizle
        await _cleanup_temp_files(cleaning_result, temp_output_path)


async def _process_personal_mode(cleaning_result: Dict, original_filename: str) -> Dict[str, Any]:
    """KiÅŸisel mail modu iÅŸlemi"""
    temp_output_path = None
    try:
        # TemizlenmiÅŸ dosyayÄ± yÃ¼kle ve formatla
        wb = load_workbook(cleaning_result["temp_path"])
        ws = wb.active
        
        # SÃ¼tun geniÅŸliklerini ayarla
        from openpyxl.utils import get_column_letter
        for column_cells in ws.columns:
            length = max(len(str(cell.value)) if cell.value else 0 for cell in column_cells)
            column_letter = get_column_letter(column_cells[0].column)
            ws.column_dimensions[column_letter].width = min(25, max(length + 2, 10))
        
        # GeÃ§ici Ã§Ä±ktÄ± dosyasÄ± oluÅŸtur
        temp_output = tempfile.NamedTemporaryFile(delete=False, suffix=".xlsx")
        temp_output_path = temp_output.name
        wb.save(temp_output_path)
        wb.close()
        
        # KiÅŸisel maile gÃ¶nder
        email_success = False
        if config.PERSONAL_EMAIL:
            subject = f"ðŸ“Š Excel Raporu - {original_filename}"
            body = (
                f"Merhaba,\n\n"
                f"{cleaning_result['row_count']} satÄ±rlÄ±k Excel raporu ekte gÃ¶nderilmiÅŸtir.\n\n"
                f"Ä°yi Ã§alÄ±ÅŸmalar,\nExcel Bot"
            )
            
            email_success = await send_email_with_attachment(
                [config.PERSONAL_EMAIL], subject, body, Path(temp_output_path)
            )
        
        return {
            "success": email_success,
            "total_rows": cleaning_result["row_count"],
            "email_sent_to": config.PERSONAL_EMAIL if email_success else None
        }
        
    except Exception as e:
        logger.error(f"KiÅŸisel mail iÅŸleme hatasÄ±: {e}")
        return {"success": False, "error": str(e)}


async def _process_normal_mode(cleaning_result: Dict) -> Dict[str, Any]:
    """Normal mod iÅŸlemi (gruplara ayÄ±rÄ±p her gruba mail)"""
    try:
        # DosyayÄ± gruplara ayÄ±r
        splitting_result = split_excel_by_groups(
            cleaning_result["temp_path"],
            cleaning_result["headers"]
        )
        
        if not splitting_result["success"]:
            error_msg = f"Excel ayÄ±rma hatasÄ±: {splitting_result.get('error', 'Bilinmeyen hata')}"
            logger.error(error_msg)
            return {"success": False, "error": error_msg}
        
        logger.info(f"Excel gruplara ayrÄ±ldÄ±: {splitting_result['total_rows']} satÄ±r, {len(splitting_result['output_files'])} grup")

        # E-postalarÄ± gÃ¶nder (async olarak)
        email_tasks = []
        output_files = splitting_result["output_files"]
        email_results = []
        
        for group_id, file_info in output_files.items():
            group_info = group_manager.get_group_info(group_id)
            recipients = group_info.get("email_recipients", [])
            
            if recipients and file_info["row_count"] > 0:
                subject = f"{group_info.get('group_name', group_id)} Raporu - {file_info['filename']}"
                body = (
                    f"Merhaba,\n\n"
                    f"{group_info.get('group_name', group_id)} grubu iÃ§in {file_info['row_count']} satÄ±rlÄ±k rapor ekte gÃ¶nderilmiÅŸtir.\n\n"
                    f"Ä°yi Ã§alÄ±ÅŸmalar,\nExcel Bot"
                )
                
                for recipient in recipients:
                    if recipient.strip():
                        task = send_email_with_attachment(
                            [recipient.strip()], subject, body, file_info["path"]
                        )
                        email_tasks.append((task, group_id, recipient, file_info["path"].name))
        
        # TÃ¼m mail gÃ¶revlerini paralel Ã§alÄ±ÅŸtÄ±r
        if email_tasks:
            logger.info(f"{len(email_tasks)} mail gÃ¶revi baÅŸlatÄ±lÄ±yor...")
            tasks = [task[0] for task in email_tasks]
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # SonuÃ§larÄ± iÅŸle
            for i, result in enumerate(results):
                task_info = email_tasks[i]
                group_id, recipient, filename = task_info[1], task_info[2], task_info[3]
                
                if isinstance(result, Exception):
                    logger.error(f"Mail gÃ¶nderim hatasÄ± - Grup: {group_id}, AlÄ±cÄ±: {recipient}, Dosya: {filename}, Hata: {result}")
                    email_results.append({
                        "success": False,
                        "group_id": group_id,
                        "recipient": recipient,
                        "error": str(result)
                    })
                else:
                    logger.info(f"Mail gÃ¶nderildi - Grup: {group_id}, AlÄ±cÄ±: {recipient}, Dosya: {filename}")
                    email_results.append({
                        "success": True,
                        "group_id": group_id,
                        "recipient": recipient
                    })
        
        successful_emails = sum(1 for res in email_results if res["success"])
        logger.info(f"Mail gÃ¶nderim sonucu: {successful_emails} baÅŸarÄ±lÄ±, {len(email_results) - successful_emails} baÅŸarÄ±sÄ±z")
        
        return {
            "success": True,
            "output_files": output_files,
            "total_rows": splitting_result["total_rows"],
            "matched_rows": splitting_result["matched_rows"],
            "email_results": email_results,
            "email_sent": successful_emails > 0
        }
        
    except Exception as e:
        logger.error(f"Normal mod iÅŸleme hatasÄ±: {e}")
        return {"success": False, "error": str(e)}


async def _process_zip_mode(cleaning_result: Dict, original_filename: str) -> Dict[str, Any]:
    """ZIP modu iÅŸlemi"""
    try:
        # DosyayÄ± gruplara ayÄ±r
        splitting_result = split_excel_by_groups(
            cleaning_result["temp_path"],
            cleaning_result["headers"]
        )
        
        if not splitting_result["success"]:
            error_msg = f"Excel ayÄ±rma hatasÄ±: {splitting_result.get('error', 'Bilinmeyen hata')}"
            logger.error(error_msg)
            return {"success": False, "error": error_msg}
        
        logger.info(f"Excel gruplara ayrÄ±ldÄ±: {splitting_result['total_rows']} satÄ±r, {len(splitting_result['output_files'])} grup")

        # TÃ¼m dosyalarÄ± ZIP yap ve PERSONAL_EMAIL'e gÃ¶nder
        zip_success = False
        output_files = splitting_result["output_files"]
        
        if output_files and config.PERSONAL_EMAIL:
            zip_success = await _send_zip_to_personal_email(output_files, original_filename)
        
        return {
            "success": zip_success,
            "output_files": output_files,
            "total_rows": splitting_result["total_rows"],
            "matched_rows": splitting_result["matched_rows"],
            "personal_email": config.PERSONAL_EMAIL,
            "zip_sent": zip_success
        }
        
    except Exception as e:
        logger.error(f"ZIP mod iÅŸleme hatasÄ±: {e}")
        return {"success": False, "error": str(e)}


async def _send_zip_to_personal_email(output_files: Dict[str, Any], original_filename: str) -> bool:
    """TÃ¼m Ã§Ä±ktÄ± dosyalarÄ±nÄ± ZIP yapÄ±p PERSONAL_EMAIL'e gÃ¶nderir"""
    if not config.PERSONAL_EMAIL:
        logger.error("PERSONAL_EMAIL tanÄ±mlÄ± deÄŸil")
        return False
    
    try:
        # ZIP dosyasÄ± oluÅŸtur
        zip_path = Path(tempfile.gettempdir()) / f"excel_output_{original_filename.split('.')[0]}.zip"
        
        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for file_info in output_files.values():
                zipf.write(file_info["path"], file_info["filename"])
        
        # Mail gÃ¶nder
        subject = f"ðŸ“Š Excel Grup RaporlarÄ± - {original_filename}"
        body = (
            f"Excel iÅŸleme sonucu oluÅŸturulan {len(output_files)} dosya ektedir.\n\n"
            f"Toplam satÄ±r: {sum(f['row_count'] for f in output_files.values())}\n"
            f"OluÅŸan gruplar: {', '.join(f['filename'] for f in output_files.values())}\n\n"
            f"Ä°yi Ã§alÄ±ÅŸmalar,\nExcel Bot"
        )
        
        success = await send_email_with_attachment(
            [config.PERSONAL_EMAIL],
            subject,
            body,
            zip_path
        )
        
        # ZIP dosyasÄ±nÄ± sil
        zip_path.unlink(missing_ok=True)
        
        if success:
            logger.info(f"ZIP dosyasÄ± baÅŸarÄ±yla gÃ¶nderildi: {config.PERSONAL_EMAIL}")
        else:
            logger.error(f"ZIP dosyasÄ± gÃ¶nderilemedi: {config.PERSONAL_EMAIL}")
        
        return success
        
    except Exception as e:
        logger.error(f"ZIP gÃ¶nderme hatasÄ±: {e}")
        return False


async def _cleanup_temp_files(cleaning_result: Dict, temp_output_path: str = None):
    """GeÃ§ici dosyalarÄ± temizler"""
    try:
        if cleaning_result and "temp_path" in cleaning_result:
            temp_path = Path(cleaning_result["temp_path"])
            if temp_path.exists():
                temp_path.unlink()
                logger.info(f"GeÃ§ici dosya silindi: {temp_path.name}")
        
        if temp_output_path and Path(temp_output_path).exists():
            Path(temp_output_path).unlink()
            logger.info(f"GeÃ§ici output dosyasÄ± silindi: {temp_output_path}")
    except Exception as e:
        logger.warning(f"GeÃ§ici dosya silinemedi: {e}")


# Geriye uyumluluk iÃ§in eski fonksiyonlar
async def process_excel_task_with_zip(input_path: Path, user_id: int) -> Dict[str, Any]:
    """ZIP modu iÃ§in geriye uyumlu fonksiyon"""
    return await process_excel_task(input_path, user_id, ProcessMode.ZIP)


async def process_excel_task_for_personal_email(input_path: Path, user_id: int) -> Dict[str, Any]:
    """KiÅŸisel mail modu iÃ§in geriye uyumlu fonksiyon"""
    return await process_excel_task(input_path, user_id, ProcessMode.PERSONAL)